const assignIDs=t=>{let e=0;const s=t=>{if(t.id=e++,t.subitems)for(const e of t.subitems)s(e)};for(const e of t)s(e);return t},flatten=t=>t.map((t=>t.subitems?.length?[t,flatten(t.subitems)].flat():t)).flat();export class TOCProgress{constructor({toc:t,ids:e,splitHref:s,getFragment:i}){assignIDs(t);const r=flatten(t),n=new Map;for(const[t,e]of r.entries()){const[i,o]=s(e?.href)??[],c={fragment:o,item:e};n.has(i)?n.get(i).items.push(c):n.set(i,{prev:r[t-1],items:[c]})}const o=new Map;for(const[t,s]of e.entries())n.has(s)?o.set(s,n.get(s)):o.set(s,o.get(e[t-1]));this.ids=e,this.map=o,this.getFragment=i}getProgress(t,e){const s=this.ids[t],i=this.map.get(s);if(!i)return null;const{prev:r,items:n}=i;if(!n)return r;if(!e||1===n.length&&!n[0].fragment)return n[0].item;const o=e.startContainer.getRootNode();for(const[t,{fragment:s}]of n.entries()){const i=this.getFragment(o,s);if(i&&e.comparePoint(i,0)>0)return n[t-1]?.item??r}return n[n.length-1].item}}export class SectionProgress{constructor(t,e,s){this.sizes=t.map((t=>"no"===t.linear?0:t.size)),this.sizePerLoc=e,this.sizePerTimeUnit=s,this.sizeTotal=this.sizes.reduce(((t,e)=>t+e),0)}getProgress(t,e,s=0){const{sizes:i,sizePerLoc:r,sizePerTimeUnit:n,sizeTotal:o}=this,c=i[t]??0,a=i.slice(0,t).reduce(((t,e)=>t+e),0)+e*c,f=a+s*c,l=o-a,g=(1-e)*c;return{fraction:f/o,section:{current:t,total:i.length},location:{current:Math.floor(a/r),next:Math.floor(f/r),total:Math.ceil(o/r)},time:{section:g/n,total:l/n}}}getSection(t){if(0===t)return[0,0];if(1===t)return[this.sizes.length-1,1];const{sizes:e,sizeTotal:s}=this,i=t*s;let r=-1,n=0,o=0;for(const[t,s]of e.entries()){const e=o+s;if(e>i){r=t,n=(i-o)/s;break}o=e}return[r,n]}}